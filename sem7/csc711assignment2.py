# -*- coding: utf-8 -*-
"""CSC711Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dscGuWr6rdoBDQBAB-FfEX1R_vTRsDCO
"""

import matplotlib.pyplot as plt
from matplotlib import rc
import numpy as np
from typing import List, Tuple
import sys

THRESHOLD: float = 0.1

"""# Generating points

Use the numpy.random function to generate random points
"""

# Generate "count" number of random points within the range 0..100
# and store them in a list of tuples
def gen_points(count: int) -> List[Tuple[int, int]]:
  X = np.random.randint(0,1001,count)
  Y = np.random.randint(0,1001,count)

  ps = [(x,y) for x,y in zip(X,Y)]
  return ps

"""# Distance formula for comparison

$dist = \sqrt{(x_2-x_1)^2 + (y_2 - y_1)^2}$
"""

def distance(P1: Tuple[int,int], P2: Tuple[int,int]) -> int | float:
  return np.sqrt((P1[0] - P2[0])**2 + (P1[1] - P2[1])**2)

"""# Brute force

Use brute force to find closest points when number of points $\leq 3$
"""

def brute(P: List[Tuple[int, int]], N: int) -> Tuple[int | float, List[Tuple[int, int]]]:
  mindist = sys.maxsize
  minpair: List[Tuple[int, int]] = []
  for i in range(N):
    for j in range(i+1, N):
      D = distance(P[i], P[j])
      if D < mindist:
        mindist = D
        # minpair = []
        minpair.append((P[i], P[j]))
      elif abs(D - mindist) < THRESHOLD:
        minpair.append((P[i], P[j]))
  return mindist, minpair

"""# Closest strip

Check if there exists a closest point between $2$ points on either side of the
halves. Use a brute force inside the strip of length $2\delta$.
"""

def strip(S: List[Tuple[int, int]], size: int, D: float | int,
          minpair: List[Tuple[int, int]]) -> Tuple[int | float, List[Tuple[int, int]]]:
    stripsort = sorted(S, key=lambda p: p[1])
    mindist: float | int = D
    minpair: List[Tuple[int, int]] = []
    for i in range(size):
      for j in range(i+1, size):
        if (stripsort[j][1] - stripsort[i][1]) > mindist:
          break
        if (stripsort[j][1] - stripsort[i][1]) == mindist:
          minpair.append((S[i], S[j]))
        if distance(stripsort[i], stripsort[j]) < mindist:
          mindist = distance(stripsort[i], stripsort[j])
          minpair = [(stripsort[i], stripsort[j])]
    return mindist, minpair

"""# Find the closest point using a divide and conquer algorithm"""

def closest(P: List[Tuple[int, int]], N: int) -> Tuple[int | float, List[Tuple[int, int]]]:
  if N <= 3:
    return brute(P, N)
  mid = N // 2
  midpt = P[mid]
  DL, pairL = closest(P, mid)
  DR, pairR = closest(P[mid:], N-mid)
  minpair = []
  if DL < DR:
    minpair = pairL
  elif DL > DR:
    minpair = pairR
  else:
    minpair = pairR + pairL
  D = min(DL, DR)
  stripPts = []
  for i in range(N):
        if abs(P[i][0] - midpt[0]) < D:
            stripPts.append(P[i])
  stripD, stripMinPair = strip(stripPts, len(stripPts), D, minpair)
  minpair = minpair if D < stripD else stripMinPair
  return min(D, stripD), minpair

"""# Run the algorithm"""

P = gen_points(100)
P = sorted(P, key=lambda p: p[0])
N = len(P)
plt.plot(np.array(P)[:, 0], np.array(P)[:, 1], 'o')
plt.title('Random Points in Space')

plt.show()

min_d, pairs = closest(P,N)
print("The smallest distance is", min_d)
print(pairs)

plt.figure(figsize=(5, 5))


plt.plot(np.array(P)[:, 0], np.array(P)[:, 1], 'o')
plt.title('Random Points in Space')

print("Min Pair")
for pair in pairs:

  # Taking points
  P1 = pair[0]
  P2 = pair[1]
  print("Pair: ", (P1,P2), ", Min Dist. = ",distance(P1,P2))

  # Mark the pts
  plt.plot([P1[0],P2[0]], [P1[1],P2[1]], 'ro', label='Closest Pair')
  # Draw the line
  plt.plot([P1[0],P2[0]], [P1[1],P2[1]], 'r-')

plt.show()